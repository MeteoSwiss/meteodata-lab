# generated by AI, no credit taken

from PIL import Image, ImageDraw, ImageSequence
import math
import os
# ---- Generate background grid as GIF

# Canvas setup
width, height = 800, 800
background_color = (255, 255, 255, 255)
blue_color = (15, 76, 129)

background = Image.new("RGBA", (width, height), background_color)
draw_bg = ImageDraw.Draw(background)

# Define blue box as center square
blue_box_margin = 0.11
blue_box = (
    int(width * blue_box_margin),
    int(height * blue_box_margin),
    int(width * (1 - blue_box_margin)),
    int(height * (1 - blue_box_margin))
)
draw_bg.rounded_rectangle(blue_box, radius=50, fill=blue_color)

# Diagonal mask
def get_diagonal_mask(size, progress, direction):
    mask = Image.new("L", size, 0)
    draw = ImageDraw.Draw(mask)
    w, h = size
    cut_x = int(w * progress)
    cut_y = int(h * progress)
    if direction == "down":
        draw.polygon([(0, 0), (cut_x, 0), (cut_x, cut_y), (0, cut_y)], fill=255)
    elif direction == "up":
        draw.polygon([(w, h), (w - cut_x, h), (w - cut_x, h - cut_y), (w, h - cut_y)], fill=255)
    return mask

# Grid drawing
def draw_rectangular_grid_centered(draw, step, color="white"):
    box_x0, box_y0, box_x1, box_y1 = blue_box
    grid_width = box_x1 - box_x0
    grid_height = box_y1 - box_y0

    # Adjust step to divide evenly
    n_cols = round(grid_width / step)
    step_x = grid_width / n_cols
    n_rows = round(grid_height / step)
    step_y = grid_height / n_rows

    for i in range(n_cols + 1):
        x = box_x0 + i * step_x
        draw.line((x, box_y0, x, box_y1), fill=color, width=1)
    for j in range(n_rows + 1):
        y = box_y0 + j * step_y
        draw.line((box_x0, y, box_x1, y), fill=color, width=1)

def draw_fully_symmetric_triangular_grid(draw, step, color="white"):
    h = step * math.sqrt(3) / 2
    cols = int(width / step) + 2
    rows = int(height / h) + 2
    x_offset = (width - (cols - 1) * step) / 2
    y_offset = (height - (rows - 1) * h) / 2

    for row in range(rows):
        for col in range(cols):
            x = col * step + (step / 2 if row % 2 else 0)
            y = row * h
            cx = x + x_offset
            cy = y + y_offset

            p1 = (cx, cy)
            p2 = (cx + step / 2, cy + h)
            p3 = (cx - step / 2, cy + h)
            draw.polygon([p1, p2, p3], outline=color)

            p4 = (cx, cy + h)
            p5 = (cx + step / 2, cy)
            p6 = (cx - step / 2, cy)
            draw.polygon([p4, p5, p6], outline=color)

# Animation parameters
triangular_step = 80
rectangular_base_step = 46
total_frames = 25
frames = []

def add_grid_cycle(grid_type, direction):
    overlay = Image.new("RGBA", (width, height))
    draw = ImageDraw.Draw(overlay)
    if grid_type == "rectangular":
        draw_rectangular_grid_centered(draw, rectangular_base_step)
    else:
        draw_fully_symmetric_triangular_grid(draw, triangular_step)

    appear_sequence = []
    for f in range(total_frames):
        progress = (f + 1) / total_frames
        mask = get_diagonal_mask((width, height), progress, direction)
        partial = Image.composite(overlay, Image.new("RGBA", (width, height)), mask)
        frame = Image.alpha_composite(background.copy(), partial)
        appear_sequence.append(frame)

    full_grid = Image.alpha_composite(background.copy(), overlay)
    frames.extend(appear_sequence)
    frames.append(full_grid)
    frames.extend([frame.rotate(180) for frame in appear_sequence[::-1]])

# Run both grid sequences
add_grid_cycle("rectangular", direction="down")
add_grid_cycle("triangular", direction="up")

# Save final refined animation
final_gif_path = "./background.gif"
frames[0].save(final_gif_path, save_all=True, append_images=frames[1:], duration=100, loop=0)


# ---- Add industrial wheel, cloud and meteswiss flag on top

# Load the updated logo and background animation
updated_logo = Image.open("./logo-base-layer.png").convert("RGBA")
background_gif = Image.open("./background.gif")

# Determine the blue box region
width, height = background_gif.size
blue_box_margin = 0.11
blue_box = (
    int(width * blue_box_margin),
    int(height * blue_box_margin),
    int(width * (1 - blue_box_margin)),
    int(height * (1 - blue_box_margin))
)

# Resize updated logo slightly to fit inside the blue box
scale_factor = 0.85
blue_box_width = blue_box[2] - blue_box[0]
blue_box_height = blue_box[3] - blue_box[1]
target_width = int(blue_box_width * scale_factor)
target_height = int(blue_box_height * scale_factor)
logo_aspect = updated_logo.width / updated_logo.height

# Maintain aspect ratio
if target_width / logo_aspect <= target_height:
    final_width = target_width
    final_height = int(target_width / logo_aspect)
else:
    final_height = target_height
    final_width = int(target_height * logo_aspect)

resized_logo = updated_logo.resize((final_width, final_height))

# Center the resized logo in the blue box
offset_x = blue_box[0] + (blue_box_width - final_width) // 2
offset_y = blue_box[1] + (blue_box_height - final_height) // 2

# Composite onto each frame
composite_frames = []
for frame in ImageSequence.Iterator(background_gif):
    frame = frame.convert("RGBA")
    frame_copy = frame.copy()
    frame_copy.paste(resized_logo, (offset_x, offset_y), resized_logo)
    composite_frames.append(frame_copy)

# Save the final animation
final_updated_output_path = "./metedata-lab_logo.gif"
composite_frames[0].save(
    final_updated_output_path,
    save_all=True,
    append_images=composite_frames[1:],
    duration=100,
    loop=0,
)
os.remove("./background.gif")



